# WO-7 — Fill by Rank + Idempotence

## Anchors to read first

* ` @docs/anchors/00_math_spec.md `
  §4 **Per-Type Quotas (Paid Ledger)** and §6 **Pixel-Level Law (Least Fill by Rank)** — build Σ per type, assign the **smallest** color (c) with `rank ≤ Σ_S(c)`, idempotence when Π+K are recomputed on (Y^*).
* ` @docs/anchors/01_math_spec_addendum.md `
  Reiterates: types are **free**, quotas are **paid** (from Y₀ only), fills are **independent per type**, and idempotence is required.

---

## Goal

Given:

* the **test type mosaic** (T_{\text{test}}) from WO-5 (transported and disjointified), and
* the **paid quotas** (K_{S,c}) for each **parent** type (S) counted on Π(Y₀) in WO-6,

produce the final grid (Y^*) by the **meet** rule:

* Take row-major ranks within each **type block** in (T_{\text{test}}).
* Compute cumulative cuts (\Sigma_S(c)=\sum_{d=0}^c K_{S,d}).
* Assign each pixel the **smallest** color (c) s.t. `rank ≤ Σ_S(c)`.
  Then **certify idempotence**: recompute Π and K on (Y^*), re-fill, and confirm `Y2 == Y*`.

**Important mapping note (from WO-5):** because disjointify creates **new** type ids in (T_{\text{test}}), we must know, for every new id (S'), which **parent** Y₀-type (S) it came from (so we can use the correct `K[S,·]`).
→ **Requirement:** WO-5 must expose (or persist in receipts) a mapping
`parent_type_id: Dict[int (S'), int (S)]`. WO-7 consumes this map.
(If it doesn’t exist yet, add it to WO-5 outputs/receipts before implementing WO-7.)

---

## Interfaces (frozen)

```python
# arc/fill.py
from typing import Dict, Tuple
import numpy as np

def fill_by_rank(
    T_test: np.ndarray,                 # test type mosaic after disjointify
    parent_of: Dict[int, int],          # new type id S' -> parent Y0 type id S
    K: Dict[int, np.ndarray],           # quotas per parent type (length-C vectors)
    C: int                              # palette size (ARC=10)
) -> np.ndarray:
    """
    Return Y* (same HxW as T_test) using the meet rule per type block.
    """

def idempotence_check(
    Y_star: np.ndarray,
    C: int
) -> bool:
    """
    Recompute Π(Y*), K'(Y*), re-fill, and check Y2 == Y* (bit-equality).
    """
```

* `K[S]` must be **length-C** with non-negative ints (from WO-6).
* `parent_of[S’]` must be present for **every** new type id in `T_test`.

---

## Exact libraries & functions to use (no custom algos)

* **Cumulative cuts Σ:** `numpy.cumsum` (documented; per type we call `np.cumsum(K[S])`) ([NumPy][1])
* **Rank → color index:** `numpy.searchsorted` with `side='left'` on Σ to get the **smallest** color whose cumulative count reaches the rank; vectorized over ranks in one call ([NumPy][2])
* **Counting colors to verify quotas:** `numpy.bincount(colors, minlength=C)` to re-count each block’s colors in receipts (paid check) ([NumPy][3])
* **Hash for receipts:** `hashlib.sha256(Y_star.astype(np.int64).tobytes()).hexdigest()` (official Python docs) ([Python documentation][4])
* **JSON Lines** for receipts output (one JSON object **per line**) ([JSON Lines][5])

No custom histogramming, no hand-rolled binary search, no Python loops over pixels beyond grouping by type. Vectorize per type where reasonable.

---

## Algorithm (precise, type-by-type)

Let (H,W=T_{\text{test}}.shape). For each **new** type id (S') in `np.unique(T_test)`:

1. Gather **row-major positions**:

   * `idx = np.flatnonzero(T_test.ravel(order="C") == S')`
   * Ranks are `ranks = np.arange(1, idx.size+1, dtype=np.int64)` (1-based as in the spec).

2. Parent lookup and Σ:

   * `S = parent_of[S']`
   * `Sigma = np.cumsum(K[S])`  (length `C`) ([NumPy][1])

3. Vectorized rank → color mapping:

   * `cols = np.searchsorted(Sigma, ranks, side="left")` (length `idx.size`) ([NumPy][2])
   * Guarantee `cols.max() < C` (Σ total must equal block size because WO-6 guaranteed `∑ K[S,·] == |S|`).

4. Write to output:

   * Prepare `Y_star = np.zeros((H,W), dtype=np.int64)` once.
   * `Y_star.ravel(order="C")[idx] = cols`

**That’s the meet.** No per-pixel branching beyond the vectorized search; no heuristics.

---

## Receipts (first-class)

For every **FREE_PROVEN** task, append one JSONL record:

```json
{
  "task_id": "…",
  "fill": {
    "C": 10,
    "blocks": [
      {
        "type_new": 17,
        "parent_type": 3,
        "count": 81,
        "Sigma": [5,5,29,29,29,81,81,81,81,81],   // example (length C)
        "quota_satisfied": true,                  // bincount == K[parent]
        "rank_minimality": true                   // see below
      }
      // ... one entry per S'
    ],
    "idempotent": true,
    "sha256_Y_star": "…"
  }
}
```

How to compute each receipt field:

* **quota_satisfied:**
  For block (S’), recompute counts:
  `blk_colors = Y_star.ravel()[idx]` (from step 1) → `np.bincount(blk_colors, minlength=C)` equals `K[parent_type]`. Mark `true` if exact match. ([NumPy][3])

* **rank_minimality:**
  For each rank `r`, we chose `c = searchsorted(Sigma, r, 'left')`. This *is* the minimal c by definition of `searchsorted` (leftmost index where Σ ≥ r) — record `true` (we can store a boolean flag rather than recompute). ([NumPy][2])

* **idempotent:**
  Run `idempotence_check(Y_star, C)`:

  1. Π on Y*: `T1 = types_from_output(Y_star)` (WO-1)
  2. K' on Y*: `K1 = quotas(Y_star, T1, C)` (WO-6 routine)
  3. Re-fill: `Y2 = fill_by_rank(T1, parent_of'=identity_map(T1), K1, C)`
     (Note: parent_of' is identity because now K is defined on the **current** types T1.)
  4. `idempotent = np.array_equal(Y2, Y_star)` (bit equality).
     Emit `idempotent: true/false` and `sha256_Y_star`.

---

## Runner changes

Add a mode:

```bash
python -m arc.solve \
  --mode fill-receipts \
  --challenges /mnt/data/arc-agi_training_challenges.json \
  --out outputs/receipts_wo7.jsonl
```

For each **FREE_PROVEN** task:

1. Load `T_test` and `parent_of` from WO-5 outputs/receipts (or re-compute once via a shared cache).
2. Load `K` from WO-6 receipts for the chosen Y₀.
3. Call `fill_by_rank(T_test, parent_of, K, C=10)` → `Y_star`.
4. Emit the receipts record above. (Use JSON Lines — one JSON object **per line**; UTF-8.) ([JSON Lines][5])

---

## Reviewer instructions (all 1000 tasks)

1. **Run**:

```bash
python -m arc.solve \
  --mode fill-receipts \
  --challenges /mnt/data/arc-agi_training_challenges.json \
  --out outputs/receipts_wo7.jsonl
```

2. **Assert (for all FREE_PROVEN tasks):**

* For **every** block entry:

  * `quota_satisfied == true` (the local histogram equals `K[parent]` exactly). Uses `np.bincount(..., minlength=C)` ([NumPy][3])
  * `rank_minimality == true` (leftmost `searchsorted` mapping) ([NumPy][2])
* `idempotent == true` (re-Π + re-K + re-fill returns the same Y*).
* SHA256 present and stable on re-run (same `sha256_Y_star` for a given task and seedless code).

3. **Classify gaps vs bugs:**

* WO-7 has **no spec gap**: for any **FREE_PROVEN** + valid K task, meet must pass.
* If `quota_satisfied` is false or `idempotent` is false for any block/task, it’s an **implementation bug** (wrong parent map, wrong Σ, wrong ranks or write order).
* Tasks **FREE_UNPROVEN** in WO-4 remain skipped here — this is correct and not a bug.

---

## Performance (CPU)

* Per type (S’), `cumsum` (O(C)), one `searchsorted` over ranks (O(|S’|)), one block write — all vectorized NumPy ops in C; overall O(H·W). No optimizations necessary beyond this.

  * `np.cumsum` for Σ ([NumPy][1])
  * `np.searchsorted` for minimal color per rank (leftmost) ([NumPy][2])
  * `np.bincount` for receipt verification ([NumPy][3])

---

## Acceptance criteria (green = WO-7 done)

* ✔ Runner completes; emits one **fill** JSONL record per **FREE_PROVEN** task.
* ✔ Every filled block passes `quota_satisfied` and `rank_minimality`.
* ✔ `idempotent == true` for all filled tasks; SHA256 included.
* ✔ Deterministic outputs across runs.
* ✔ Code ≤ ~200 LOC in `arc/fill.py` + small runner plumbing; uses only the cited NumPy/stdlib calls.

---

[1]: https://numpy.org/doc/2.1/reference/generated/numpy.cumsum.html?utm_source=chatgpt.com "numpy.cumsum — NumPy v2.1 Manual"
[2]: https://numpy.org/devdocs/reference/generated/numpy.searchsorted.html?utm_source=chatgpt.com "numpy.searchsorted — NumPy v2.4.dev0 Manual"
[3]: https://numpy.org/doc/2.1/reference/generated/numpy.bincount.html?utm_source=chatgpt.com "numpy.bincount — NumPy v2.1 Manual"
[4]: https://docs.python.org/3/library/hashlib.html?utm_source=chatgpt.com "hashlib — Secure hashes and message digests"
[5]: https://jsonlines.org/?utm_source=chatgpt.com "JSON Lines"
