# WO-5 — Transport Types + Disjointify

## Anchors to read first

* ` @docs/anchors/00_math_spec.md ` — §5 *Shape Map (Free Transport)* and A2 (lawful composition).
* ` @docs/anchors/01_math_spec_addendum.md ` — finite FREE library; SBS obligations; transport acts on **types** only; replicated copies must be kept **disjoint**.

## Goal

Given:

* a **proven** FREE terminal for a task from WO-4 (one of: `identity`, `h-mirror-concat`, `v-double`, `h/v-concat-dup`, `tile`, `SBS-Y`, `SBS-param`);
* the **training output types** (T_{!Y_0}=\Pi(Y_0)) (chosen later for quotas, but used here only as the source type pattern);
* the **test input** (X^*) and its shape ((H,W)),

produce the **test type mosaic** (T_{\text{test}}) **exactly** as that FREE map dictates, and then **disjointify** (connected-component relabel) so fills cannot bleed across replicated blocks.

---

## Interface (frozen)

```python
# arc/transport.py
from typing import Tuple, Dict, Any
import numpy as np

def transport_types(
    T_train: np.ndarray,                 # Π(Y0)
    free_tuple: Tuple[str, Tuple[Any,...]],  # e.g., ("tile",(sh,sw)) or ("SBS-Y",(sh,sw,σ,...))
    X_test_shape: Tuple[int,int],        # (H,W)
    X_test: np.ndarray | None,           # needed for SBS-* selection only
) -> np.ndarray:
    """
    Build T_test per the proven FREE terminal (types-only), then disjointify.
    Returns T_test (np.ndarray[int], shape = output canvas).
    """
```

Deterministic: no RNG; row-major decisions; fixed tie-breaks from WO-4.

---

## Exact libraries & functions to use (no custom algos)

**NumPy primitives for transport**

* **Concatenation**: `numpy.concatenate([...], axis=1)` (horizontal), `axis=0` (vertical). Official doc. ([NumPy][1])
* **Left/right flip**: `numpy.fliplr(X)` (O(1) view). Official doc. ([NumPy][2])
* **vstack/hstack** (if clearer for the implementer): `numpy.vstack`, `numpy.hstack` (thin wrappers around `concatenate`). ([NumPy][3])
* **Tiling** (repeat base pattern): `numpy.tile(base, (sh, sw))`. Official doc. ([NumPy][4])
* **Wrap-index selection** (alternative to tiling): `numpy.take(a, idx, axis=?, mode="wrap")`. Official doc. ([NumPy][5])
* **Reshape & move axes** (for SBS block grids):
  `arr.reshape(H, sh, W, sw)` then `np.moveaxis(arr, 1, 2)` so each block sits at `blocks[i, j]` with shape `(sh, sw)`. Official docs. ([NumPy][6])

**Connected-component labeling for disjointify**

* Use `skimage.measure.label(T, connectivity=1)` to split **each type id** into 4-connected components with **distinct labels** (then remap to a dense id range). Official skimage docs. ([Scikit-image][7])
  *(If you prefer stdlib only, a simple DFS is acceptable; but skimage is mature and removes algorithm risk.)*

No other packages. Do **not** implement your own CCL, flips, tiles, or reshapes.

---

## Transport logic per terminal (precise)

In all cases, the **payload is types**, never colors.

Let ((H,W)=X^*.shape) and (T_{!Y_0}) be the training types.

### 1) `identity`

* Output shape: ((H,W)) must equal (T_{!Y_0}.shape); set `T_test = T_Y0.copy()`.

### 2) `h-mirror-concat`

* Output shape: ((H, 2W)).
* Two variants from WO-3A: `"rev|id"` or `"id|rev"`.
* Build with **fliplr** and **concatenate**:
  `np.concatenate([np.fliplr(T_Y0), T_Y0], axis=1)` for `"rev|id"`, reversed for `"id|rev"`. ([NumPy][2])

### 3) `v-double`

* v0 definition = duplicate vertically:
  `np.concatenate([T_Y0, T_Y0], axis=0)`. ([NumPy][1])

### 4) `h/v-concat-dup`

* Horizontal: `np.concatenate([T_Y0, T_Y0], axis=1)`; vertical: `axis=0`. ([NumPy][1])

### 5) `tile (sh, sw)` (types-periodic)

* Baseline: `T_test = np.tile(T_Y0, (sh, sw))`. ([NumPy][4])
* Alternative (no large allocation):

  ```
  rows = np.arange(H*sh) % H
  cols = np.arange(W*sw) % W
  T_test = T_Y0.take(rows, axis=0, mode='wrap').take(cols, axis=1, mode='wrap')
  ```

  (same result; pure types). ([NumPy][5])

### 6) `SBS-Y (sh, sw, σ, templates...)`

* **Block grid** over the **test** canvas: size `(H*sh, W*sw)`.
* Build an empty `T_test` of that shape.
* For each cell `(i, j)` in the **test input** `X*`, compute `v = X*[i, j]`, lookup `m = σ[v]`, and place the **Π(Y) template** `B^{(m)}` into the block slice:

  ```
  r0, r1 = i*sh, (i+1)*sh
  c0, c1 = j*sw, (j+1)*sw
  T_test[r0:r1, c0:c1] = Bm           # types only
  ```
* **Then disjointify** (see below) so repeated placements yield **distinct** type ids.

### 7) `SBS-param (sh, sw, σ, templates from Π(X))`

* Exactly as SBS-Y, but the per-value template comes from **Π(X)** (as proven in WO-3D).
* For v0, our canonical template is the **replication of the Π(X) type** at `(i,j)` into a `(sh, sw)` block (the proof object must encode the template id per value). Place into each block as above, then disjointify.

---

## Disjointify (4-connected components)

After any terminal that replicates blocks (`tile`, `h/v-dup`, `mirror-concat`, `SBS-*`), apply **4-connected** component labeling to ensure **no fill can cross block boundaries**:

1. **Per original type id**: isolate all pixels with that id (`mask = (T_test == t)`), then run `measure.label(mask, connectivity=1)` to get component labels. Official API. ([Scikit-image][7])
2. Assign **new global ids** to each non-zero component and write them into `T_test`.
3. Make ids **dense** (0..K-1) in row-major order for determinism.

(If you prefer to label the full canvas in one pass, you must encode `(type_id, component_id)` into a dense new id; the per-type loop is clearer and avoids accidental merging across different type ids.)

---

## Receipts (first-class)

For every task with FREE_PROVEN, append one JSON object to the JSONL receipts:

```json
{
  "task_id": "…",
  "transport": {
    "terminal": ["SBS-Y", [3,3]],
    "in_shape":  [H0, W0],         // T_Y0 shape
    "test_shape": [H*sh, W*sw],

    "pre_disjoint": {
      "unique_type_ids":  N_before,
      "example_type_counts": {"5": 81, "6": 81}   // optional sample
    },
    "post_disjoint": {
      "unique_type_ids":  N_after,                // >= N_before
      "components_labeled": true
    },

    // For tiling/SBS: per-block evidence
    "block_evidence": {
      "grid": [H, W],
      "sh": 3, "sw": 3,
      "template_hashes": {"0": "…", "7": "…"},    // carried over from WO-3C/3D
      "blocks_match": true                        // every block equals its template before disjointify
    }
  }
}
```

* `test_shape` **must** equal the FREE map’s implied output size.
* For tiling/SBS, we require `blocks_match == true` pre-disjointify, i.e., every block slice equals its proven template **by exact `array_equal`** (computed during transport).
* Post-disjointify, `unique_type_ids` should increase or remain (never fewer), reflecting separated copies.

---

## Runner changes

Add a mode:

```bash
python -m arc.solve \
  --mode transport-receipts \
  --challenges /mnt/data/arc-agi_training_challenges.json \
  --out outputs/receipts_wo5.jsonl
```

Behavior per **FREE_PROVEN** task:

1. Load **one** `T_Y0 = Π(Y0)` (it’s already available from earlier WOs).
2. Call `transport_types(T_Y0, free_tuple, X_test.shape, X_test)`.
3. Emit the receipts above.

Use the same JSON Lines discipline: one JSON object per line; UTF-8. ([NumPy][3])

---

## Reviewer instructions (all 1000)

1. **Run**:

   ```bash
   python -m arc.solve \
     --mode transport-receipts \
     --challenges /mnt/data/arc-agi_training_challenges.json \
     --out outputs/receipts_wo5.jsonl
   ```

2. **Check**:

   * `test_shape` equals the FREE map’s implied shape (e.g., `tile` → `(sh*H, sw*W)`; mirror-concat → `(H, 2W)`; etc.).
   * For tiling/SBS entries, confirm `blocks_match == true` (every block equals its template by an **exact** NumPy equality).
   * `post_disjoint.unique_type_ids ≥ pre_disjoint.unique_type_ids` and `components_labeled == true`.

3. **Classify gaps vs bugs**:

   * If a task was **FREE_UNPROVEN** in WO-4, it is **not** exercised here (this is expected).
   * Shape mismatch, missing or false `blocks_match`, or unchanged component counts after disjointify are **implementation bugs** (transport or labeling error), not spec gaps.

---

## Performance (CPU)

All operations are vectorized and O(total pixels):

* Concatenation (`concatenate`, `hstack/vstack`) and flipping (`fliplr`) are C-level ops. ([NumPy][1])
* Tiling via `np.tile` or wrapped `take` is C-level. ([NumPy][4])
* Reshape/moveaxis for SBS is C-level reshape/view logic. ([NumPy][6])
* `skimage.measure.label` is a mature, optimized CCL implementation. ([Scikit-image][7])
  No optimizations or shortcuts are permitted beyond these—correctness first.

---

## Acceptance criteria (green = WO-5 done)

* ✔ Runner completes for all **FREE_PROVEN** tasks; one JSONL record per task.
* ✔ `test_shape` always equals the FREE map’s implied shape.
* ✔ For tiling/SBS, **every block** equals its template by exact equality before disjointify (`blocks_match == true`).
* ✔ Post-disjointify, labels are 4-connected and **dense**, and the count of unique type ids does not drop.
* ✔ Deterministic across runs.
* ✔ Code `arc/transport.py` + small runner plumbing; uses only the cited APIs.

---

[1]: https://numpy.org/doc/stable/reference/generated/numpy.concatenate.html?utm_source=chatgpt.com "numpy.concatenate — NumPy v2.3 Manual"
[2]: https://numpy.org/doc/2.1/reference/generated/numpy.fliplr.html?utm_source=chatgpt.com "numpy.fliplr — NumPy v2.1 Manual"
[3]: https://numpy.org/devdocs/reference/generated/numpy.vstack.html?utm_source=chatgpt.com "numpy.vstack — NumPy v2.4.dev0 Manual"
[4]: https://numpy.org/devdocs/reference/generated/numpy.tile.html?utm_source=chatgpt.com "numpy.tile — NumPy v2.4.dev0 Manual"
[5]: https://numpy.org/doc/2.2/reference/generated/numpy.take.html?utm_source=chatgpt.com "numpy.take — NumPy v2.2 Manual"
[6]: https://numpy.org/devdocs/reference/generated/numpy.reshape.html?utm_source=chatgpt.com "numpy.reshape — NumPy v2.4.dev0 Manual"
[7]: https://scikit-image.org/docs/0.25.x/api/skimage.measure.html?utm_source=chatgpt.com "skimage.measure — skimage 0.25.2 documentation"
