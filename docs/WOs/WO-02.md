# WO-2 — Harness + Receipts Skeleton

## Anchors to read first

* `docs/anchors/00_math_spec.md` — §0–§4, especially the Π requirement and idempotence (this WO only exercises Π receipts).
* `docs/anchors/01_math_spec_addendum.md` — no change to Π; this WO is Π-only receipts.

## Goal

Provide a **deterministic corpus runner** that loads the ARC JSON, iterates all tasks, and emits **Π receipts** (from WO-1) for every **training output** (and optionally for test inputs to sanity-probe Π). No FREE/transport/quotas/fill yet.

## Module & CLI surface (frozen)

```
arc/
  receipts.py     # JSONL writer + sha256 helpers
  solve.py        # runner modes, including --mode pi-receipts
```

```python
# arc/receipts.py
from pathlib import Path
from typing import Iterable, Mapping, Any
import numpy as np

def sha256_bytes(b: bytes) -> str: ...
def sha256_ndarray(A: np.ndarray) -> str: ...
def write_jsonl(path: Path, records: Iterable[Mapping[str, Any]]) -> None: ...
```

```python
# arc/solve.py
from pathlib import Path
from typing import Dict, Any, List

def load_tasks_from_json(path: Path) -> Dict[str, Dict[str, Any]]: ...
def run_pi_receipts(tasks: Dict[str, Dict[str, Any]], out_path: Path) -> None: ...
def main() -> None: ...   # argparse-based CLI
```

## Exact libraries & functions to use (no custom algos)

* **JSONL output** (one JSON per line): follow the JSON Lines spec; each line is an independent JSON object written with `textio.write(json.dumps(obj) + "\n")`. Do **not** invent a format. ([jsonlines.org][1])
* **Hashing**: `hashlib.sha256` to compute deterministic hex digests (for type mosaics and codebooks). ([Python documentation][2])
* **CLI**: `argparse` from the standard library (we do not need Typer here). Use a subcommand or a `--mode` flag; parse `--challenges` and `--out`. ([Python documentation][3])
* **Paths**: `pathlib.Path` for all file I/O paths; no raw string paths. ([Python documentation][4])
* **Logging**: stdlib `logging` for a single INFO summary line; no third-party loggers. ([Python documentation][5])
* **NumPy**: consume outputs from WO-1 (`types_from_output`) and use `ndarray.tobytes()` for hashing; no pickle. If you persist arrays for debugging, use `numpy.save` `.npy`, not ad-hoc. ([numpy.org][6])

> Everything above is standard, mature, and documented. No other packages are needed.

## What the runner does (precise)

For each **task id** in the challenges JSON:

1. For each **training output** grid `Y`:

   * Call `arc.pi.types_from_output(Y)` (from WO-1).
   * Recompute Π on the same `Y` to check idempotence.
   * Emit a **Π receipt** line (schema below).

2. Optionally (enabled by `--include-test-pi` flag), also compute Π receipts for the **test input** grid(s) (useful to catch sentinel/edge bugs early).

3. Write **one JSONL file** with one line per processed grid; print a final summary: number of tasks, number of grids, and count of failures (should be zero for WO-1).

## Receipt schema (Π-only, first-class)

For each processed grid:

```json
{
  "task_id": "007bbfb7",
  "grid_role": "train_output",    // or "test_input" if --include-test-pi
  "grid_index": 0,                // which train pair index
  "H": 9, "W": 9,

  // Π idempotence
  "sha256_T": "…",           // sha256 of Π(Y) type mosaic
  "sha256_T_again": "…",          // sha256 of Π(Y) recomputed
  "pass_idempotent": true,

  // Codebook stability (features->type ids)
  "codebook_sha256": "…",

  // Partition totals
  "type_sizes": {"0": 81, "1": 12, "2": 6},   // compact map
  "sum_sizes": 99,
  "pass_sum": true
}
```

* `sha256_T_*` computed with `hashlib.sha256(A.astype(np.int64).tobytes()).hexdigest()`; deterministic across runs. ([Python documentation][2])
* `write_jsonl` must open in text mode UTF-8 and append exactly one newline per record, per JSON Lines spec. ([jsonlines.org][1])

## How this WO proves math 1:1 (without GT)

* **Idempotence** (`pass_idempotent`): certifies Π²=Π on every grid, as required by the anchors.
* **Codebook stability**: certifies that the φ→type mapping is deterministic and not order-dependent.
* **Partition totals** (`pass_sum`): certifies that Π produced a full partition of Ω with no losses/overlaps (counts sum to H·W).
  Together these receipts prove the **free observation** step is correct everywhere, per anchors §3, without any ground truth labels.

## Runner usage (reviewer instructions, all 1000)

**Command**:

```bash
python -m arc.solve \
  --mode pi-receipts \
  --challenges /mnt/data/arc-agi_training_challenges.json \
  --out outputs/receipts_wo2.jsonl
```

**What to check** (zero guesswork):

* Scan the final summary line (INFO) for:
  `tasks=1000 grids=<#> idempotence_fail=0 sum_fail=0`
* Grep the JSONL for any `false` in `pass_idempotent` or `pass_sum` — there should be **none**.
* Re-run the command; confirm **no** line changed its `sha256_T_once/sha256_T_twice/codebook_sha256` (determinism).

**How to identify a legit “gap” vs. an implementation bug**:

* There is **no legitimate gap** at WO-2: Π must succeed on every grid.
* Any failure is an implementation mismatch with anchors (e.g., wrong padding, wrong neighbor offsets, non-deterministic codebook). Escalate to the implementer of WO-1/WO-2; do **not** proceed to later WOs until green.

## File formats & I/O (overspecified)

* **Challenges JSON** loader returns a dict `id -> payload` with canonicalized shapes:

  * `payload["train"]` is a list of dicts with `"input"` and `"output"` arrays.
  * `payload["test"]` is a list with one dict containing `"input"`.
* Use `pathlib.Path` for all paths; create parent dirs with `Path(...).parent.mkdir(parents=True, exist_ok=True)`. ([Python documentation][4])
* JSONL writing: open with `Path.open("w", encoding="utf-8")`; write one `json.dumps(obj, separators=(",", ":"), ensure_ascii=False)` plus `"\n"` per record. Follow the JSON Lines requirement “one JSON object per line.” ([jsonlines.org][1])

## Logging (single INFO line)

Configure stdlib `logging` with level INFO and print only a final summary line:
`Processed tasks=<N>, grids=<M>, idempotence_fail=<a>, sum_fail=<b>`. No chatty logs. ([Python documentation][5])

## Performance note

The pass is **O(total pixels)** and CPU-light: reading JSON, calling Π (already vectorized), hashing bytes, and writing text lines. No optimizations or shortcuts are permitted; do not “compress” receipts or skip any grid.

---

## Acceptance criteria (green = WO-2 done)

* ✔ Command runs on all 1000 tasks without error.
* ✔ JSONL contains one record per processed grid, with all required fields.
* ✔ All `pass_idempotent` and `pass_sum` are `true`.
* ✔ Re-running produces identical `sha256_*` and `codebook_sha256` for every record (determinism).
* ✔ Code is ≤ ~200 LOC across `arc/receipts.py` and `arc/solve.py` for this mode (stitching only; no custom algorithms).

---

[1]: https://jsonlines.org/?utm_source=chatgpt.com "JSON Lines"
[2]: https://docs.python.org/3/library/hashlib.html?utm_source=chatgpt.com "hashlib — Secure hashes and message digests"
[3]: https://docs.python.org/3/library/argparse.html?utm_source=chatgpt.com "argparse — Parser for command-line options, arguments ..."
[4]: https://docs.python.org/3/library/pathlib.html?utm_source=chatgpt.com "pathlib — Object-oriented filesystem paths"
[5]: https://docs.python.org/3/library/logging.html?utm_source=chatgpt.com "logging — Logging facility for Python"
[6]: https://numpy.org/doc/2.1/reference/generated/numpy.save.html?utm_source=chatgpt.com "numpy.save — NumPy v2.1 Manual"
