# WO-4 — FREE Intersection + Pick (Frozen Order)

## Anchors to read first

* ` @docs/anchors/00_math_spec.md ` — §5 *Shape Map (Free Transport)*: “one map proved from trainings” and lawful composition (A2).
* ` @docs/anchors/01_math_spec_addendum.md ` — finite library of FREE morphisms + SBS obligation and **intersection across trainings**.

## Goal

For a **task** with multiple train pairs ((X_i!\to Y_i)), consume the **per-pair candidates** produced by WO-3A..3D and:

1. **Intersect** them across all pairs **per terminal kind and parameters**.
2. Apply the **frozen simplicity order** to **pick exactly one terminal** for v0:

   1. `identity`
   2. `{h-mirror-concat, v-double, h-concat-dup, v-concat-dup}`
   3. `tile`
   4. `SBS-Y`
   5. `SBS-param`
3. Prefer **no D4** and **no translate** (v0 keeps these slots as “none”).
4. Emit receipts: all per-pair candidates, the **intersection set**, and the **chosen** terminal with params (or mark FREE_UNPROVEN with reason).

No heuristics, no fallbacks other than “unproven”.

---

## Interfaces (frozen)

```python
# arc/free_prove.py
from typing import Dict, Any, List, Tuple, Optional

Kind    = str        # "identity", "h-mirror-concat", "v-double", "h-concat-dup", "v-concat-dup", "tile", "SBS-Y", "SBS-param"
Params  = Tuple[Any, ...] | None
Cand    = Tuple[Kind, Params]

def prove_free(task: Dict[str, Any],
               per_pair_simple: List[List[Cand]],
               per_pair_tile:   List[Optional[Cand]],
               per_pair_sbs_y:  List[Optional[Cand]],
               per_pair_sbs_p:  List[Optional[Cand]]
              ) -> Tuple[str, Dict[str, Any]]:
    """
    Returns:
      ("FREE_PROVEN", {"chosen": Cand, "intersected": List[Cand], "order_rank": int})
      or
      ("FREE_UNPROVEN", {"reason": str, "intersected": List[Cand]})
    """
```

* `per_pair_simple[i]` is the ordered list from WO-3A for pair `i`.
* `per_pair_tile[i]` is either None or `("tile",(sh,sw))` from WO-3B.
* `per_pair_sbs_y[i]` is either None or `("SBS-Y", (...))` from WO-3C.
* `per_pair_sbs_p[i]` is either None or `("SBS-param", (...))` from WO-3D.

---

## Exact libraries & functions (no custom algorithms)

* **Set intersection:** build Python `set` of `(kind, params)` per pair and intersect with `set.intersection` (or the `&` operator). This is the canonical, documented way to intersect N sets. ([W3Schools][1])
* **Stable ordering for “pick”:** build a sortable key `(rank(kind), str(params))` and pass to `sorted`. Python’s `sorted()` is **stable**, so ties preserve the prior order deterministically. ([Python documentation][2])
* **CLI plumbing:** stdlib `argparse` (recommended in official docs), with `--mode free-intersect-pick`. ([Python documentation][3])
* **Paths:** `pathlib.Path` for I/O; never raw string paths. ([Python documentation][4])
* **JSON Lines:** write **one JSON object per line**, UTF-8, newline-delimited; follow JSONL’s three requirements. ([JSON Lines][5])
* **Hashing (optional receipt integrity):** `hashlib.sha256` for any “chosen tuple” digest. ([Python documentation][6])

No extra packages are required beyond Python stdlib and NumPy (only to carry arrays from prior WOs; WO-4 itself uses sets/strings).

---

## Intersection & pick logic (precise)

### 1) Gather candidates per pair

Normalize all per-pair candidates to a common list of `(kind, params)`:

* For **simple**: directly use the emitted list.
* For **tile / SBS-Y / SBS-param**: if not None, append the single tuple.
* For each pair `i`, create a `set_i = set(candidates_i)`.

### 2) Intersect across all pairs

```
inter = set_i0 ∩ set_i1 ∩ ... ∩ set_i(m-1)
```

Using `set.intersection` (or `&`). If any pair has **no** candidates (empty set), the intersection is empty. ([W3Schools][1])

### 3) Decide outcome

* If `inter` is empty → `"FREE_UNPROVEN"`, reason `"empty_intersection"`, include `intersected=[]`.
* Else sort `list(inter)` by **frozen order** and pick index 0.

Frozen order rank:

```python
order = {
  "identity": 0,
  "h-mirror-concat": 1,
  "v-double": 1,
  "h-concat-dup": 1,
  "v-concat-dup": 1,
  "tile": 2,
  "SBS-Y": 3,
  "SBS-param": 4,
}
# pick with: sorted(inter, key=lambda (k,p): (order.get(k, 99), str(p)))
```

Python sorts are **stable**, so if two items share the same rank, `str(params)` breaks the tie deterministically. ([Python documentation][2])

### 4) D4/translate slots (v0)

Slots exist conceptually but are **always “none”** in v0. We do **not** consider D4/translate in the pick; they’re carried as `None` and later ignored by transport.

---

## Receipts (first-class)

Emit **one task-level JSON** (JSONL) with everything the reviewer needs; example:

```json
{
  "task_id": "6d0aefbc",
  "free_intersection": {
    "per_pair": [
      { "pair_index": 0,
        "candidates": [
          ["identity", null],
          ["h-mirror-concat", "rev|id"],
          ["h-concat-dup", null]
        ]
      },
      { "pair_index": 1,
        "candidates": [
          ["identity", null],
          ["h-concat-dup", null]
        ]
      }
    ],
    "intersected": [
      ["identity", null],
      ["h-concat-dup", null]
    ],
    "chosen": ["identity", null],
    "order_rank": 0,
    "chosen_sha256": "..."  // OPTIONAL: sha256(json.dumps(chosen, sort_keys=True).encode())
  }
}
```

* `per_pair.candidates` **must** mirror exactly what WO-3 emitted (order preserved).
* `intersected` is the exact set intersection (converted to a sorted list by the pick key).
* `chosen` and `order_rank` show the frozen policy application.

JSON Lines spec: one JSON object per line; this file can be appended to the global receipts stream or written separately. ([JSON Lines][5])

---

## Runner changes

Add a mode:

```bash
python -m arc.solve \
  --mode free-intersect-pick \
  --challenges /mnt/data/arc-agi_training_challenges.json \
  --out outputs/receipts_wo4.jsonl
```

Behavior per task:

1. Call WO-3A..3D to get the per-pair candidates.
2. Call `prove_free(...)`.
3. Write the **single** task-level JSON record above to the JSONL.

Command-line parsing via stdlib `argparse`; Path handling via `pathlib.Path`. ([Python documentation][3])

---

## Reviewer instructions (all 1000 tasks)

1. **Run:**

   ```bash
   python -m arc.solve \
     --mode free-intersect-pick \
     --challenges /mnt/data/arc-agi_training_challenges.json \
     --out outputs/receipts_wo4.jsonl
   ```
2. **Audit quickly:**

   * For a few tasks, manually compute the **intersection**: take the **set** of `(kind, params)` from each pair and intersect; confirm it equals `intersected`. (This is textbook `set.intersection` in Python.) ([W3Schools][1])
   * Confirm the **chosen** equals the minimal by the frozen order, then lexicographic `str(params)` tie-break; Python `sorted()` is **stable**, so results are deterministic. ([Python documentation][2])
3. **Classify gaps vs bugs:**

   * If `intersected` is empty, that is **not** an implementation bug; it means the task needs another FREE family (to be added in v1/v2), and is correctly labeled `"FREE_UNPROVEN"`.
   * If a candidate appears in `intersected` that **was not present** in all pairs, or the order/pick ignores the frozen map, that’s an **implementation bug** (intersection or ordering wrong).
   * No heuristics are allowed: the receipts define the math 1:1.

---

## Performance (CPU)

* Work is tiny: set construction + intersections + a single `sorted`. No optimizations or refactors needed. Python set ops and sorting are well-tuned in CPython. ([Python documentation][7])

---

## Acceptance criteria (green = WO-4 done)

* ✔ Runs over the full corpus; produces **one** JSONL record per task.
* ✔ `intersected` equals the true set intersection across all pairs; `chosen` obeys the frozen order.
* ✔ Deterministic across runs (same `chosen`, same hashes).
* ✔ Code  `arc/free_prove.py` + small runner plumbing; uses only `set.intersection`, `sorted`, `argparse`, `pathlib`, JSONL.

---

[1]: https://www.w3schools.com/python/ref_set_intersection.asp?utm_source=chatgpt.com "Python Set intersection() Method"
[2]: https://docs.python.org/3/howto/sorting.html?utm_source=chatgpt.com "Sorting Techniques — Python 3.14.0 documentation"
[3]: https://docs.python.org/3/library/argparse.html?utm_source=chatgpt.com "argparse — Parser for command-line options, arguments ..."
[4]: https://docs.python.org/3/library/pathlib.html?utm_source=chatgpt.com "pathlib — Object-oriented filesystem paths"
[5]: https://jsonlines.org/?utm_source=chatgpt.com "JSON Lines"
[6]: https://docs.python.org/3/library/hashlib.html?utm_source=chatgpt.com "hashlib — Secure hashes and message digests"
[7]: https://docs.python.org/3/library/stdtypes.html?utm_source=chatgpt.com "Built-in Types"
